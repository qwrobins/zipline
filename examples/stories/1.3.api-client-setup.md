# Story 1.3: API Client & React Query Setup

## Status
Ready for Review

## Story
**As a** developer,
**I want** a configured API client with React Query for data fetching and caching,
**so that** all data operations have consistent error handling, loading states, and cache management.

## Acceptance Criteria
1. React Query provider configured in root layout with sensible defaults (staleTime, cacheTime, retry logic)
2. API client utility created with base URL for JSONPlaceholder (https://jsonplaceholder.typicode.com)
3. TypeScript types defined for all JSONPlaceholder entities (Post, User, Comment, Todo)
4. Zod schemas created for runtime validation of API responses
5. Custom hooks created: `usePosts`, `usePost`, `useUsers`, `useUser`
6. Error handling utility for API failures with user-friendly messages
7. React Query DevTools installed and accessible in development mode
8. Sonner toast provider configured in root layout for global notifications

## Tasks / Subtasks
- [x] Configure React Query provider in root layout (AC: 1)
  - [x] Create lib/query-client.ts with QueryClient configuration
  - [x] Create app/providers.tsx with QueryClientProvider wrapper
  - [x] Add Providers to app/layout.tsx
  - [x] Configure sensible defaults: staleTime (5 min), cacheTime (10 min), retry (2)
- [x] Create base API client utility (AC: 2, 6)
  - [x] Create lib/api/client.ts with base URL constant
  - [x] Implement apiFetch function with error handling
  - [x] Create APIError class for typed errors
  - [x] Add user-friendly error message mapping utility
- [x] Define TypeScript types for JSONPlaceholder entities (AC: 3)
  - [x] Create types/index.ts
  - [x] Define Post type with id, userId, title, body
  - [x] Define User type with id, name, username, email, address, phone, website, company
  - [x] Define Comment type with id, postId, name, email, body
  - [x] Define Todo type with id, userId, title, completed
  - [x] Export all types
- [x] Create Zod schemas for runtime validation (AC: 4)
  - [x] Create lib/api/schemas.ts
  - [x] Define postSchema with Zod
  - [x] Define userSchema with Zod
  - [x] Define commentSchema with Zod
  - [x] Define todoSchema with Zod
  - [x] Define array schemas (postArraySchema, userArraySchema, etc.)
  - [x] Export all schemas
- [x] Create API service functions (AC: 2, 4)
  - [x] Create lib/api/posts.ts with fetchPosts, fetchPost functions
  - [x] Create lib/api/users.ts with fetchUsers, fetchUser functions
  - [x] Create lib/api/comments.ts with fetchComments function
  - [x] Create lib/api/todos.ts with fetchTodos function
  - [x] Integrate Zod validation in all fetch functions
- [x] Create centralized query keys (AC: 5)
  - [x] Create lib/query-keys.ts
  - [x] Define query key factories for posts, users, comments, todos
  - [x] Use hierarchical structure for cache invalidation
- [x] Create React Query hooks (AC: 5)
  - [x] Create lib/hooks/use-posts.ts with usePosts hook (list query)
  - [x] Create lib/hooks/use-post.ts with usePost hook (single query)
  - [x] Create lib/hooks/use-users.ts with useUsers hook (list query)
  - [x] Create lib/hooks/use-user.ts with useUser hook (single query)
  - [x] Integrate queryKeys in all hooks
  - [x] Add proper TypeScript return types
- [x] Install and configure React Query DevTools (AC: 7)
  - [x] Install @tanstack/react-query-devtools
  - [x] Add ReactQueryDevtools to Providers component
  - [x] Verify DevTools only active in development mode
- [x] Configure Sonner toast provider (AC: 8)
  - [x] Verify sonner installed (should be from Story 1.1)
  - [x] Import Toaster from sonner
  - [x] Add Toaster to root layout
  - [x] Test toast notifications with sample error

## Dev Notes

### React Query Configuration
[Source: docs/architecture/tech-stack.md]

TanStack Query (React Query) v5.x is required for server state and cache management (NFR9). It provides optimistic updates capability (NFR10).

**Installation:**
React Query should already be installed from Story 1.1. Verify in package.json:
```json
{
  "@tanstack/react-query": "^5.0.0",
  "@tanstack/react-query-devtools": "^5.0.0"
}
```

**Query Client Configuration:**
[Source: docs/architecture/frontend-architecture.md]
```typescript
// lib/query-client.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: 2,
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});
```

**Provider Setup:**
```typescript
// app/providers.tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState } from 'react';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000,
        cacheTime: 10 * 60 * 1000,
        retry: 2,
        refetchOnWindowFocus: false,
      },
      mutations: {
        retry: 1,
      },
    },
  }));

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### API Client Structure
[Source: docs/architecture/components.md, docs/architecture/frontend-architecture.md]

**Base API Client:**
```typescript
// lib/api/client.ts
import { z } from 'zod';

const BASE_URL = 'https://jsonplaceholder.typicode.com';

class APIError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public response?: unknown
  ) {
    super(message);
    this.name = 'APIError';
  }
}

async function apiFetch<T>(
  endpoint: string,
  options?: RequestInit,
  schema?: z.ZodSchema<T>
): Promise<T> {
  const url = `${BASE_URL}${endpoint}`;

  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    });

    if (!response.ok) {
      throw new APIError(
        `API request failed: ${response.statusText}`,
        response.status
      );
    }

    const data = await response.json();

    // Validate response with Zod schema
    if (schema) {
      return schema.parse(data);
    }

    return data as T;
  } catch (error) {
    if (error instanceof APIError) {
      throw error;
    }
    throw new APIError('Network request failed', 0, error);
  }
}

export { apiFetch, APIError, BASE_URL };
```

### TypeScript Types
[Source: docs/architecture/components.md]

**Type Definitions:**
```typescript
// types/index.ts
export interface Post {
  id: number;
  userId: number;
  title: string;
  body: string;
}

export interface User {
  id: number;
  name: string;
  username: string;
  email: string;
  address: {
    street: string;
    suite: string;
    city: string;
    zipcode: string;
    geo: {
      lat: string;
      lng: string;
    };
  };
  phone: string;
  website: string;
  company: {
    name: string;
    catchPhrase: string;
    bs: string;
  };
}

export interface Comment {
  id: number;
  postId: number;
  name: string;
  email: string;
  body: string;
}

export interface Todo {
  id: number;
  userId: number;
  title: string;
  completed: boolean;
}
```

### Zod Schemas
[Source: docs/architecture/tech-stack.md, docs/architecture/coding-standards.md]

Zod v3.x is required for runtime type validation (NFR13). All API responses must be validated with Zod schemas before use.

```typescript
// lib/api/schemas.ts
import { z } from 'zod';

export const postSchema = z.object({
  id: z.number(),
  userId: z.number(),
  title: z.string(),
  body: z.string(),
});

export const userSchema = z.object({
  id: z.number(),
  name: z.string(),
  username: z.string(),
  email: z.string().email(),
  address: z.object({
    street: z.string(),
    suite: z.string(),
    city: z.string(),
    zipcode: z.string(),
    geo: z.object({
      lat: z.string(),
      lng: z.string(),
    }),
  }),
  phone: z.string(),
  website: z.string(),
  company: z.object({
    name: z.string(),
    catchPhrase: z.string(),
    bs: z.string(),
  }),
});

export const commentSchema = z.object({
  id: z.number(),
  postId: z.number(),
  name: z.string(),
  email: z.string().email(),
  body: z.string(),
});

export const todoSchema = z.object({
  id: z.number(),
  userId: z.number(),
  title: z.string(),
  completed: z.boolean(),
});

// Array schemas
export const postArraySchema = z.array(postSchema);
export const userArraySchema = z.array(userSchema);
export const commentArraySchema = z.array(commentSchema);
export const todoArraySchema = z.array(todoSchema);
```

### Query Keys
[Source: docs/architecture/frontend-architecture.md, docs/architecture/coding-standards.md]

Query Key Consistency is critical: Always use centralized queryKeys object; never hardcode strings.

```typescript
// lib/query-keys.ts
export const queryKeys = {
  posts: {
    all: ['posts'] as const,
    lists: () => [...queryKeys.posts.all, 'list'] as const,
    list: (filters?: { userId?: number; page?: number }) =>
      [...queryKeys.posts.lists(), filters] as const,
    details: () => [...queryKeys.posts.all, 'detail'] as const,
    detail: (id: number) => [...queryKeys.posts.details(), id] as const,
  },
  users: {
    all: ['users'] as const,
    lists: () => [...queryKeys.users.all, 'list'] as const,
    list: () => [...queryKeys.users.lists()] as const,
    details: () => [...queryKeys.users.all, 'detail'] as const,
    detail: (id: number) => [...queryKeys.users.details(), id] as const,
  },
  comments: {
    all: ['comments'] as const,
    lists: () => [...queryKeys.comments.all, 'list'] as const,
    list: (postId: number) => [...queryKeys.comments.lists(), postId] as const,
  },
  todos: {
    all: ['todos'] as const,
    lists: () => [...queryKeys.todos.all, 'list'] as const,
    list: (filters?: { userId?: number }) =>
      [...queryKeys.todos.lists(), filters] as const,
  },
} as const;
```

### API Service Functions
[Source: docs/architecture/components.md, docs/architecture/frontend-architecture.md]

**Posts Service:**
```typescript
// lib/api/posts.ts
import { apiFetch } from './client';
import { postSchema, postArraySchema } from './schemas';
import type { Post } from '@/types';

export async function fetchPosts(params?: {
  userId?: number;
  page?: number;
}): Promise<Post[]> {
  const searchParams = new URLSearchParams();
  if (params?.userId) searchParams.set('userId', params.userId.toString());

  const query = searchParams.toString();
  const endpoint = `/posts${query ? `?${query}` : ''}`;

  return apiFetch(endpoint, undefined, postArraySchema);
}

export async function fetchPost(id: number): Promise<Post> {
  return apiFetch(`/posts/${id}`, undefined, postSchema);
}
```

**Users Service:**
```typescript
// lib/api/users.ts
import { apiFetch } from './client';
import { userSchema, userArraySchema } from './schemas';
import type { User } from '@/types';

export async function fetchUsers(): Promise<User[]> {
  return apiFetch('/users', undefined, userArraySchema);
}

export async function fetchUser(id: number): Promise<User> {
  return apiFetch(`/users/${id}`, undefined, userSchema);
}
```

### React Query Hooks
[Source: docs/architecture/components.md]

**Example Hook:**
```typescript
// lib/hooks/use-posts.ts
import { useQuery } from '@tanstack/react-query';
import { fetchPosts } from '@/lib/api/posts';
import { queryKeys } from '@/lib/query-keys';

export function usePosts(filters?: { userId?: number; page?: number }) {
  return useQuery({
    queryKey: queryKeys.posts.list(filters),
    queryFn: () => fetchPosts(filters),
  });
}
```

### Sonner Toast Configuration
[Source: docs/architecture/tech-stack.md]

Sonner is required for toast notifications (NFR11) and provides accessible announcements.

```typescript
// app/layout.tsx
import { Toaster } from 'sonner';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>
          {children}
        </Providers>
        <Toaster />
      </body>
    </html>
  );
}
```

### File Structure
[Source: docs/architecture/unified-project-structure.md]

```
lib/
├── api/                    # API client and services
│   ├── client.ts          # Base API client with apiFetch
│   ├── schemas.ts         # Zod schemas
│   ├── posts.ts           # Posts service functions
│   ├── users.ts           # Users service functions
│   ├── comments.ts        # Comments service functions
│   └── todos.ts           # Todos service functions
├── hooks/                  # React Query hooks
│   ├── use-posts.ts
│   ├── use-post.ts
│   ├── use-users.ts
│   └── use-user.ts
├── query-keys.ts          # Centralized query keys
└── query-client.ts        # Query client configuration
```

### Error Handling
[Source: docs/architecture/coding-standards.md]

- Catch and display user-friendly errors
- Use toast notifications for feedback
- All API responses must be validated with Zod schemas

Error message mapping utility:
```typescript
// lib/api/client.ts (add to existing file)
export function getErrorMessage(error: unknown): string {
  if (error instanceof APIError) {
    if (error.statusCode === 404) return 'Resource not found';
    if (error.statusCode >= 500) return 'Server error. Please try again later.';
    return error.message;
  }
  return 'An unexpected error occurred';
}
```

### Testing
[Source: docs/architecture/testing-strategy.md]

For this story, focus on:
- Verify React Query provider renders without errors
- Verify API client can fetch data from JSONPlaceholder
- Test each custom hook manually by creating a test page
- Verify Zod validation works (pass invalid data and check for errors)
- Verify React Query DevTools appears in development mode
- Test toast notifications display correctly

Create a test page at `app/api-test/page.tsx` to manually verify hooks:
```typescript
'use client';

import { usePosts } from '@/lib/hooks/use-posts';
import { useUsers } from '@/lib/hooks/use-users';

export default function APITestPage() {
  const { data: posts, isLoading: postsLoading } = usePosts();
  const { data: users, isLoading: usersLoading } = useUsers();

  return (
    <div className="container mx-auto py-8">
      <h1>API Test Page</h1>

      <section>
        <h2>Posts ({postsLoading ? 'Loading...' : posts?.length})</h2>
        <pre>{JSON.stringify(posts?.slice(0, 2), null, 2)}</pre>
      </section>

      <section>
        <h2>Users ({usersLoading ? 'Loading...' : users?.length})</h2>
        <pre>{JSON.stringify(users?.slice(0, 2), null, 2)}</pre>
      </section>
    </div>
  );
}
```

Unit tests will be added in later stories.

### Coding Standards
[Source: docs/architecture/coding-standards.md]

- Enable TypeScript strict mode; no `any` types without justification
- All API responses must be validated with Zod schemas
- Always use centralized queryKeys object; never hardcode strings
- Use React Query DevTools for debugging (development only)

### File Naming Conventions
[Source: docs/architecture/coding-standards.md]

- Hooks: camelCase with 'use' prefix (e.g., `use-posts.ts`, `use-user.ts`)
- Utilities: camelCase (e.g., `client.ts`, `schemas.ts`)
- Types: PascalCase (e.g., `Post`, `User`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `BASE_URL`)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-09-30 | 1.1 | Story implementation completed - React Query setup, API client, hooks, types, schemas, DevTools, and Sonner configured | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
No debug log entries required - implementation was straightforward

### Completion Notes
- Successfully implemented complete React Query infrastructure with provider, DevTools, and optimized caching
- Created robust API client with Zod validation and comprehensive error handling
- Built full TypeScript type system for all JSONPlaceholder entities
- Implemented centralized query key factory for efficient cache management
- Created four custom React Query hooks (usePosts, usePost, useUsers, useUser)
- Configured Sonner toast provider for global notifications
- Created manual test page at /api-test for verification
- Fixed theme-provider.tsx type import (used ComponentProps instead of deprecated dist/types import)
- Installed @radix-ui/react-icons and class-variance-authority for shadcn components
- Used gcTime instead of deprecated cacheTime in React Query v5
- All builds passing, linting clean, dev server operational

### File List
**Created:**
- app/providers.tsx
- lib/api/client.ts
- lib/api/schemas.ts
- lib/api/posts.ts
- lib/api/users.ts
- lib/api/comments.ts
- lib/api/todos.ts
- lib/query-keys.ts
- lib/hooks/use-posts.ts
- lib/hooks/use-post.ts
- lib/hooks/use-users.ts
- lib/hooks/use-user.ts
- types/index.ts
- app/api-test/page.tsx

**Modified:**
- app/layout.tsx - Added Providers wrapper and Toaster
- components/theme-provider.tsx - Fixed type import for next-themes compatibility
- package.json - Added @tanstack/react-query-devtools, @radix-ui/react-icons, class-variance-authority

## QA Results
_To be filled by QA Agent_