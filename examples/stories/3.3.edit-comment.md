# Story 3.3: Edit Comment (Optimistic UI)

## Status
Approved

## Story
**As a** user,
**I want** to edit my comment after posting it,
**so that** I can fix mistakes or update my thoughts.

## Acceptance Criteria
1. Edit button (icon or text) displayed on each comment (in dropdown menu or inline)
2. Clicking edit opens inline edit form or dialog with current comment text
3. Edit form includes same validation as create form (Zod schema)
4. Submitting edit triggers optimistic update: comment text updates immediately in list
5. Success toast notification displayed ("Comment updated!")
6. Mock PUT request sent to `/comments/{id}` with updated data
7. Cancel button reverts to original comment text without saving
8. Error handling: if mock PUT fails, rollback optimistic update and show error toast
9. Loading/submitting state shown during request

## Tasks / Subtasks
- [ ] Create API service for updating comment (AC: 6)
  - [ ] Add updateComment function to /lib/api/comments.ts
  - [ ] Accept commentId and CommentFormData parameters
  - [ ] Send PUT request to `/comments/{id}`
  - [ ] Return updated comment from server
- [ ] Create React Query mutation hook with optimistic update (AC: 4, 8)
  - [ ] Create useUpdateComment hook in /lib/hooks/use-comments.ts
  - [ ] Implement useMutation with optimistic update logic
  - [ ] Update React Query cache immediately with edited comment
  - [ ] Implement onError rollback to restore previous cache state
  - [ ] Invalidate comments query on success to sync with server
- [ ] Create CommentActions component with edit button (AC: 1)
  - [ ] Create /components/comments/comment-actions.tsx
  - [ ] Add edit button (icon or text) to component
  - [ ] Use DropdownMenu from shadcn/ui for actions menu (optional)
  - [ ] Handle edit button click to trigger edit mode
- [ ] Add edit mode state to CommentItem component (AC: 2, 7)
  - [ ] Update /components/comments/comment-item.tsx
  - [ ] Add local state for isEditing boolean
  - [ ] Conditionally render edit form or comment display
  - [ ] Pass current comment data to edit form as default values
  - [ ] Implement cancel handler to exit edit mode without saving
- [ ] Create inline edit form or reuse CommentForm (AC: 2, 3, 7, 9)
  - [ ] Option 1: Create separate inline edit form in CommentItem
  - [ ] Option 2: Extract shared form component and reuse for create/edit
  - [ ] Use React Hook Form with Zod validation
  - [ ] Pre-fill form with current comment data
  - [ ] Add Save and Cancel buttons
  - [ ] Show loading state on Save button during mutation
  - [ ] Use shadcn/ui Input, Textarea, Button components
- [ ] Integrate toast notifications (AC: 5, 8)
  - [ ] Use Sonner for toast notifications
  - [ ] Show success toast on successful comment update
  - [ ] Show error toast on mutation failure with rollback
  - [ ] Ensure toast messages are user-friendly
- [ ] Update CommentList to handle optimistic updates (AC: 4)
  - [ ] Ensure CommentList re-renders when cache updates
  - [ ] Display edited comment immediately in list
  - [ ] Handle transition from edit mode to display mode
- [ ] Integrate CommentActions into CommentItem (AC: 1)
  - [ ] Add CommentActions component to CommentItem
  - [ ] Position edit button appropriately (top-right corner or inline)
  - [ ] Ensure proper styling and accessibility

## Dev Notes

### API Service for Updating Comments
[Source: docs/architecture/components.md]

**Service Function:**
```typescript
// lib/api/comments.ts
export async function updateComment(
  id: number,
  data: CommentFormData
): Promise<Comment> {
  return apiFetch(`/comments/${id}`, {
    method: 'PUT',
    body: JSON.stringify(data),
  }, commentSchema);
}
```

**Dependencies:** Native Fetch API, Zod schemas for validation
**Technology Stack:** TypeScript, Zod for runtime validation

### Optimistic Updates with React Query
[Source: docs/architecture/coding-standards.md]

**Critical Rule:** All mutations must implement optimistic updates with rollback logic

**Optimistic Update Pattern for Edit:**
```typescript
// lib/hooks/use-comments.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { updateComment } from '@/lib/api/comments';
import { queryKeys } from '@/lib/api/query-keys';
import type { Comment, CommentFormData } from '@/types';

export function useUpdateComment(postId: number) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: number; data: CommentFormData }) =>
      updateComment(id, data),

    // Optimistic update: immediately update comment in cache
    onMutate: async ({ id, data }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({
        queryKey: queryKeys.comments.list(postId),
      });

      // Snapshot previous value
      const previousComments = queryClient.getQueryData<Comment[]>(
        queryKeys.comments.list(postId)
      );

      // Optimistically update cache
      queryClient.setQueryData<Comment[]>(
        queryKeys.comments.list(postId),
        (old = []) =>
          old.map((comment) =>
            comment.id === id
              ? { ...comment, name: data.name, email: data.email, body: data.body }
              : comment
          )
      );

      // Return context with snapshot
      return { previousComments };
    },

    // Rollback on error
    onError: (err, variables, context) => {
      if (context?.previousComments) {
        queryClient.setQueryData(
          queryKeys.comments.list(postId),
          context.previousComments
        );
      }
    },

    // Always refetch after error or success
    onSettled: () => {
      queryClient.invalidateQueries({
        queryKey: queryKeys.comments.list(postId),
      });
    },
  });
}
```

### Immutable State Updates
[Source: docs/architecture/coding-standards.md]

**Critical Rule:** Never mutate React Query cache directly; use setQueryData with immutable updates

**Correct Pattern for Update:**
```typescript
// Correct: Immutable update using map
queryClient.setQueryData<Comment[]>(
  queryKeys.comments.list(postId),
  (old = []) =>
    old.map((comment) =>
      comment.id === id ? { ...comment, ...updatedData } : comment
    )
);

// Incorrect: Mutating cache directly
// const comments = queryClient.getQueryData(key);
// const comment = comments.find(c => c.id === id);
// comment.body = newBody; // NEVER DO THIS
```

### Component Structure
[Source: docs/architecture/unified-project-structure.md]

**Component Files:**
```
components/
└── comments/
    ├── comment-list.tsx      # Already created in Story 3.1
    ├── comment-item.tsx      # Update in this story for edit mode
    ├── comment-form.tsx      # Already created in Story 3.2, may reuse
    └── comment-actions.tsx   # Create in this story
```

### Edit Mode Pattern
**CommentItem with Edit State:**
```typescript
'use client';

import { FC, useState } from 'react';
import { Card, CardHeader, CardContent } from '@/components/ui/card';
import { CommentActions } from './comment-actions';
import { CommentEditForm } from './comment-edit-form';
import type { Comment } from '@/types';

interface CommentItemProps {
  comment: Comment;
  postId: number;
}

export const CommentItem: FC<CommentItemProps> = ({ comment, postId }) => {
  const [isEditing, setIsEditing] = useState(false);

  if (isEditing) {
    return (
      <CommentEditForm
        comment={comment}
        postId={postId}
        onCancel={() => setIsEditing(false)}
        onSuccess={() => setIsEditing(false)}
      />
    );
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-start justify-between">
        <div className="flex flex-col gap-1">
          <span className="font-semibold">{comment.name}</span>
          <span className="text-sm text-muted-foreground">{comment.email}</span>
        </div>
        <CommentActions
          commentId={comment.id}
          onEdit={() => setIsEditing(true)}
        />
      </CardHeader>
      <CardContent>
        <p className="text-sm">{comment.body}</p>
      </CardContent>
    </Card>
  );
};
```

### Edit Form Component Pattern
```typescript
'use client';

import { FC } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent } from '@/components/ui/card';
import { useUpdateComment } from '@/lib/hooks/use-comments';
import { commentFormSchema, CommentFormData } from '@/lib/utils/validators';
import { toast } from 'sonner';
import type { Comment } from '@/types';

interface CommentEditFormProps {
  comment: Comment;
  postId: number;
  onCancel: () => void;
  onSuccess: () => void;
}

export const CommentEditForm: FC<CommentEditFormProps> = ({
  comment,
  postId,
  onCancel,
  onSuccess,
}) => {
  const { mutate, isPending } = useUpdateComment(postId);

  const form = useForm<CommentFormData>({
    resolver: zodResolver(commentFormSchema),
    defaultValues: {
      name: comment.name,
      email: comment.email,
      body: comment.body,
    },
  });

  const onSubmit = (data: CommentFormData) => {
    mutate(
      { id: comment.id, data },
      {
        onSuccess: () => {
          toast.success('Comment updated!');
          onSuccess();
        },
        onError: () => {
          toast.error('Failed to update comment. Please try again.');
        },
      }
    );
  };

  return (
    <Card>
      <CardContent className="pt-6">
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          <Input
            {...form.register('name')}
            placeholder="Your name"
            disabled={isPending}
          />
          {form.formState.errors.name && (
            <p className="text-sm text-red-500">{form.formState.errors.name.message}</p>
          )}

          <Input
            {...form.register('email')}
            type="email"
            placeholder="Your email"
            disabled={isPending}
          />
          {form.formState.errors.email && (
            <p className="text-sm text-red-500">{form.formState.errors.email.message}</p>
          )}

          <Textarea
            {...form.register('body')}
            placeholder="Edit your comment..."
            disabled={isPending}
          />
          {form.formState.errors.body && (
            <p className="text-sm text-red-500">{form.formState.errors.body.message}</p>
          )}

          <div className="flex gap-2">
            <Button type="submit" disabled={isPending}>
              {isPending ? 'Saving...' : 'Save'}
            </Button>
            <Button type="button" variant="outline" onClick={onCancel} disabled={isPending}>
              Cancel
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
};
```

### shadcn/ui Components to Use
[Source: docs/architecture/components.md]

- `Button` for edit, save, and cancel actions
- `DropdownMenu` for actions menu (optional)
- `Input` and `Textarea` for edit form fields
- `Card`, `CardHeader`, `CardContent` for layout
- Icons from `lucide-react` for edit icon

### Toast Notifications
[Source: docs/architecture/tech-stack.md]

**Notification System:** Sonner for accessible toast notifications

**Toast Usage:**
```typescript
import { toast } from 'sonner';

// Success toast
toast.success('Comment updated!');

// Error toast
toast.error('Failed to update comment. Please try again.');
```

### Form Validation
[Source: docs/architecture/coding-standards.md]

**Critical Rule:** Use React Hook Form + Zod for all forms; no uncontrolled inputs

**Reuse Validation Schema from Story 3.2:**
```typescript
// lib/utils/validators.ts
export const commentFormSchema = z.object({
  name: z.string().min(3, 'Name must be at least 3 characters'),
  email: z.string().email('Invalid email address'),
  body: z.string().min(10, 'Comment must be at least 10 characters'),
});
```

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Critical Rules:**
- **Form Validation:** Use React Hook Form + Zod for all forms; no uncontrolled inputs
- **Optimistic Updates:** All mutations must implement optimistic updates with rollback logic
- **Query Key Consistency:** Always use centralized queryKeys object; never hardcode strings
- **Immutable State:** Never mutate React Query cache directly; use setQueryData with immutable updates
- **Error Handling:** Catch and display user-friendly errors; use toast notifications for feedback
- **Accessibility:** All interactive elements must have proper ARIA labels and keyboard navigation

**Naming Conventions:**
- Components: PascalCase (`CommentActions.tsx`, `CommentEditForm.tsx`)
- Hooks: camelCase with 'use' prefix (`useUpdateComment.ts`)
- Types/Interfaces: PascalCase (`CommentEditFormProps`)

### Query Key Consistency
[Source: docs/architecture/coding-standards.md]

**Critical Rule:** Always use centralized queryKeys object; never hardcode strings

**Use Centralized Query Keys:**
```typescript
// Correct
queryClient.invalidateQueries({
  queryKey: queryKeys.comments.list(postId),
});

// Incorrect
// queryClient.invalidateQueries({ queryKey: ['comments', postId] });
```

### Accessibility
[Source: docs/architecture/coding-standards.md]

**Critical Rule:** All interactive elements must have proper ARIA labels and keyboard navigation

- Edit button should have aria-label="Edit comment"
- Cancel button should have aria-label="Cancel editing"
- Ensure keyboard navigation works for all actions
- Focus management when entering/exiting edit mode

### Testing
[Source: docs/architecture/testing-strategy.md]

**Unit Tests Required:**
- `tests/unit/components/comments/comment-item.test.tsx`
  - Switches to edit mode when edit button clicked
  - Exits edit mode when cancel button clicked
  - Displays edit form with pre-filled values
  - Shows save and cancel buttons in edit mode
- `tests/unit/components/comments/comment-actions.test.tsx`
  - Renders edit button
  - Calls onEdit handler when clicked

**Integration Tests Required:**
- `tests/integration/comment-crud.test.tsx`
  - Updates comment with optimistic UI update
  - Shows success toast after update
  - Rolls back optimistic update on error
  - Shows error toast on failure
  - Comment updates immediately in list
  - Cancel button reverts without saving

**E2E Tests Required:**
- `tests/e2e/comments/edit-comment.spec.ts`
  - Navigate to post detail page with comments
  - Click edit button on a comment
  - Verify edit form appears with current comment text
  - Modify comment text and submit
  - Verify comment updates immediately (optimistic update)
  - Verify success toast displays
  - Verify edit mode exits after save
  - Test cancel button reverts to original text
  - Test validation errors for invalid input
  - Test error handling for API failure

**Integration Test Example:**
```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import { CommentItem } from '@/components/comments/comment-item';

const mockComment = {
  id: 1,
  postId: 1,
  name: 'John Doe',
  email: 'john@example.com',
  body: 'Original comment text',
};

const server = setupServer(
  rest.put('https://jsonplaceholder.typicode.com/comments/1', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({ ...mockComment, body: 'Updated comment text' })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('CommentItem Edit Flow', () => {
  it('updates comment with optimistic UI', async () => {
    const user = userEvent.setup();
    const queryClient = new QueryClient();

    render(
      <QueryClientProvider client={queryClient}>
        <CommentItem comment={mockComment} postId={1} />
      </QueryClientProvider>
    );

    // Click edit button
    await user.click(screen.getByLabelText(/edit comment/i));

    // Verify edit form appears
    expect(screen.getByDisplayValue('Original comment text')).toBeInTheDocument();

    // Update comment text
    const textarea = screen.getByDisplayValue('Original comment text');
    await user.clear(textarea);
    await user.type(textarea, 'Updated comment text');

    // Submit form
    await user.click(screen.getByRole('button', { name: /save/i }));

    // Verify optimistic update (comment updates immediately)
    expect(await screen.findByText('Updated comment text')).toBeInTheDocument();

    // Verify success toast
    await waitFor(() => {
      expect(screen.getByText(/comment updated/i)).toBeInTheDocument();
    });

    // Verify edit mode exited
    expect(screen.queryByRole('button', { name: /save/i })).not.toBeInTheDocument();
  });
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

## QA Results
_To be filled by QA Agent_